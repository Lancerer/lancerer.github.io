---
layout: post
title:  "c语言的题目"
date:   2018-10-11 21:47
categories: c
tags: c
excerpt: c
mathjax: true
---
Evernote Export    body, td { font-family: 微软雅黑; font-size: 10pt; }  

C语言例题：

    宏定义：[http://www.cnblogs.com/haore147/p/3646934.html](http://www.cnblogs.com/haore147/p/3646934.html)

    三目运算符：[https://blog.csdn.net/yuanzhuohang/article/details/5176303](https://blog.csdn.net/yuanzhuohang/article/details/5176303)

    结构体：[https://blog.csdn.net/zw1996/article/details/53844585](https://blog.csdn.net/zw1996/article/details/53844585)

    print的格式化输出：[https://blog.csdn.net/veronica001/article/details/52450821](https://blog.csdn.net/veronica001/article/details/52450821)

    scanf的格式化输入：[http://c.biancheng.net/cpp/html/34.html](http://c.biancheng.net/cpp/html/34.html)

C语言之位运算/原码/反码/补码：[https://blog.csdn.net/u011146511/article/details/70155014](https://blog.csdn.net/u011146511/article/details/70155014)

          

![](C语言例题：_files/Image.png)

进制转换：

   十进制转换成r进制：

        方法：除r取余，一直到商为0，结果就是余数倒序排列

  

    r进制转换成十进制：

        方法：10101=1\*2^0+0\*2^1+1\*2^2+0\*2^3+1*2^4

              371=1\*8^0+7\*8^1+3*8^2;

  

    二进制转换成十六进制：

        方法：从右向左，四位一段，分别转换，不够四位的补零

            (0101110)2=(0010,1110)2=(1\*2^1,1\*2^3+1\*2^2+1\*2^1)=2E

    二进制转换成八进制：方法同上类似就是变成三位一段

  

  

**原码，反码，补码**

**    原码：  
**

**        最高位表示符号位，剩下的位数，是这个数的绝对值的二进制，符号位1表示负数，0表示正数  
**

** eg：10的原码：00000000 00000000 00000000 00001010  
**

**           -10的原码：10000000 00000000 00000000 00001010  
**

**    反码：  
**

**        正数的反码和其原码是一样的，负数的反码就是在其原码的基础上，符号位不变，其他位数取反  
**

**   eg：10的反码：00000000 00000000 00000000 00001010  
**

**            -10的反码: 11111111 11111111 11111111 11110101  符号位不变其他位数取反  
**

**    补码：  
**

**        正数的补码就是本身，负数的补码就是在反码的基础上+1  
**

**      已知十进制求二进制：  
**

**            求正整数的二进制：除二取余，直到商为零，余数倒序排序  
**

**            求负整数的二进制：先求与该负数相对应的正整数二进制代码，然后将所有位取反， 末尾加一，不够位数时，左边补一  
**

**            求零的二进制：全是零  
**

**     原码转补码：  
**

                   正数：就是本身的二进制

                   负数：符号位不变，其他位取反，在加一  

    ** 补码转原码：**  

                   正数：就是本身的二进制  

                   负数：符号位为1，其他位取反，再加一  

  

**位运算符（计算机内部存储是以补码形式）：**

**按位与运算（&）：  
**

**一个比特（Bit）位只有0和1两个取值，只有参与&运算的两个位都为1时，结果才为1，否则为0。例如1&1为1，0&0为0，1&0也为0，这和逻辑运算符&&非常类似。**

**    eg：9&5等价于：**

**            00000000 00000000 00000000 00001001  9的二进制补码  
**

**         &00000000 00000000 00000000 00000101   5的二进制补码**

**结果：  00000000 00000000 00000000 00000001  1的二进制补码    当两个都是1的时候才是1  
**

**按位或运算（|）：**

参与|运算的两个二进制位有一个为1时，结果就为1，两个都为0时结果才为0。例如1|1为1，0|0为0，1|0为1，这和逻辑运算中的||非常类似。

eg：9&5等价于：

 00000000 00000000 00000000 00001001  9的二进制补码

   |00000000 00000000 00000000 00000101   5的二进制补码

结果：  00000000 00000000 00000000 00001101  13的二进制补码    当两个有一个是1的时候就是1

  

**按位异或运算（^）:**

参与^运算两个二进制位不同时，结果为1，相同时结果为0。例如0^1为1，0^0为0，1^1为0。

    eg：9&5等价于：

 00000000 00000000 00000000 00001001  9的二进制补码

^00000000 00000000 00000000 00000101   5的二进制补码

  
结果：  00000000 00000000 00000000 00001100  12的二进制补码    相同为0，不同为1

      

**取反运算（~）:**

取反运算符~为单目运算符，右结合性，作用是对参与运算的二进制位取反。例如~1为0，~0为1，这和逻辑运算中的!非常类似

        eg:~9等价于：  

        ~00000000 00000000 00000000 00001001 9的二进制补码  

**结果：11111111 11111111 11111111 11110110 -10的二进制补码**

**左移运算（<<）:**

左移运算符<<用来把操作数的各个二进制位全部左移若干位，高位丢弃，低位补0。

例如，9<<3可以转换为如下的运算：

<< 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001 （9在内存中的存储）

\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-

0000 0000 -- 0000 0000 -- 0000 0000 -- 0100 1000 （72在内存中的存储）

所以9<<3的结果为72。

  

**视频结论：i<<3表示把i的所有二进制位左移3位，右边补零，左移n位相当于乘以2的n次方**

  

  

基础：

1. C语言源程序文件经过C编译程序编译连接之后生成一个后缀为\_\_C\_\_\_\_的文件。

     A、”.c”     B、“.obj”     C、“.exe”     D、“.bas”

2.C目标文件的扩展名是：.obj(C语言源程序经过C语言编译程序编译之后生成一个后缀为.OBJ的二进制文件，称作目标文件)

  

2.简单的程序设计一般经过以下几个步骤：1、确定数据结构。2、确定算法。3、编码。4、在计算机上调试程序。5、整理并写出文档资料。

  

3.C语言中规定标识符只能有字母，数字，下划线三种字符组成，并且首字符只能是下划线或者字母

  

4.在C语言中，char型数据在内存中的存储形式是:ascll码（注意不是补码形式）

  

**变量与数据类型：**

1\. 在做strlen（）方面的题目时候记住有转义字符一说：strlen("\\t\\"\\065\\xff\\n"）%d=5    strlen("\\tab\\n\\012\\\\")=7    strlen("stop\\0\\n")=4

控制符号位：int j=1； j*=-1；

  

2.C语言中的常量

(1).整型常量分为：十进制(只能出现0-9数字)    eg：0,1，-9；八进制(以零开头，0-7的数字)    eg：011，0123，十六进制(0x开头，0-9，a-f)    eg：0x5a整型常量

(2).实型常量分为：十进制小数形式(小数点前或者后可以没数字，但是不能同时没数字)    eg：3.1415，--9.8，0.0；指数形式(由十进制整型常量部分和之偶数部分组成，e表示底数为10后面是幂)    字母e或者E之前必须有数字    eg：e15（缺少十进制小数部分）    0.35e（缺少阶码即十的几次方）78e-1.2(不是整数阶码)

(3) 符号常量则是指用C语言标识符定义的常量符号常量可以用宏定义表示也可以用const关键字表征。如：#define PI 3.14 const float PI = 3.14

(4)字符型常量必须用单引号括起来。如：'M' , '\\n'

(5)字符串常量应用双引号括起来。如："abc" , "a",c中规定以字符'\\0'作为字符串结束标志，所以“abc”中实际上有四个字符

  

 C语言语法规定，字母e或E之前必须要有数字，且e或E后面的指数必须为整数。如e3、5e3.6、.e、e等都是非法的指数形式。在字母e或E的前后以及数字之间不得插入空格。 

  

3.char 占一个字节，int占四个字节，double占八个字节 使用sizeof输出相应的大小

  

45、以下程序片段的输出结果是_C     char str\[\]="ab\\n\\012\\\\\""    ;printf (8d", atrlen(3tr)) 

        A.3    B.4    C.6    D.12

  

6.下列程序段的輸出是_ \_5 8\_ 

int f(int x){    static y=1;    y++；    x +=y:    return x;}

void main(){    int k;    k=f(3);    printf("%d %d\\n", k, f(k);}    //这里的y是静态变量，不释放，所以在计算k（5）时 ，y经过前一轮++后y=2

  

7\. char s \[\]="abcdef";     s\[3\]='\\0';     printf("%s\\n",s);   //输出 abc 

  

![](C语言例题：_files/Image [1].png)

运算符与表达式：

  
**1.运算符的优先级：算数运算符（加减乘除，取余数）>关系运算符（大于小于等于==）>逻辑运算符（与或非）>赋值运算符（=）**

**2.在使用逻辑运算符时必须要注意短路问题，&&左边为假就一定是假，右边将不会再执行  
**

**3.任何整数和-1做&运算其值不变eg：8 &  -1=8    ；任何一个整数与同一个整数连做两次^运算，其值不变eg：8^5^5=8;**

**    8：00001000  
**

**  &-1：11111111  
**

**       00001000   8  
**

3. 表达式!(x>0&&y>0)等价于 (A) 

     A. ! (x>0) || ! (y>0)     B. !x>0 || !y>0     C. !x>0 && !y>0     D. !(x>0) && ! (y>0) 

4. 表达式 !(x>0||y>0) 等价于\_\_D\_\_\_

     A、!x>0||!y>0     B、!(x>0)||!(y>0)     C、!x>0&&!y>0     D、!(x>0)&&!(y>0) 

22. 设有 int x=11; 则表达式 (x++ * 1/3) 的值是 (A) 

      A) 3     B) 4     C) 11     D) 12

4. 下列程序段的输出结果是\_\_\_12\_\_\_

     printf("%xn", (0x19 <<1) & 0x17); 

  

5.设有以下语句： char a=3,b=6,c; c=a^b<<2; 则c的二进制值是 : A

     A) 00011011     B）00010100     C）00011100     D）00011000 

  

6.设有语句char a='\\72';则变量a ：A

    A）包含1个字符     B）包含2个字符     C）包含3个字符     D）说明不合法 

  

24\. int a=1,    b=4,    c=2;     float x=10..5 , y=4.0 , z    ;     z=(a+b)/c+sqrt((double)y)*1.2/c+x;     pritnf( "%f\\n",z) ：C

    A) 14.000000     B) 015.400000     C) 13.700000     D) 14.900000 

  

1.sizeof(double)是　:C 

    A）一种函数调用     B）一个双精度型表达式     C）一个整型表达式     D）一个不合法的表达式 

  

2.int a=2,c=5; printf( "a=%%d,b=%%d\\n",a,c) : D

    A) a=%2,b=%5     B) a=2,b=5     C) a=%%d,b=%%d     D) a=%d,b=%d

3.int x=10,    y=3,    z;     printf("%d\\n",z=(x%y,x/y));   逗号运算符取后面计算得到的值即z=x/y；

  

4.int x=-1;   执行表达式++x||++x||++x后，x的值是？

x的值为1.||（或运算符）&&（与运算符）都具有短路功能。也就是说多个条件参加或运算，那么直到出现第一个真值，之后的所有条件就不再判断。同理说多个条件参加与运算，那么出现第一个假值，之后的所有条件就不再判断。所以++x||++x||++x第一个条件++x他的值为0，也就是假，判断第二个条件，此时x=0.那么++x=1，条件为真，此时x=1。所以不再执行最后一个++x，所以x=1.使用程序测试结果也是如此。

  

6.int a=1,b=2,c=3,d=4;  printf("%d\\n",a<b?a:c<d?a:d);    //答案是：1    等价于：a>b?a:(c<d?c:d)  这种运算要从右边第一个冒号开始计算

  

 7. int x=5;  if(x++>5)    printf("%d\\n",x); else  printf("%d\\n",x--);//后置--在表达式中不进行计算，出了表达式在计算，所以答案是：6

  

10、若定乂: int a=5,b=2,c=1;则表达式 a-b>cIIb==c 的値是 1表込式a- b>c&&b==c的値是0

  

11.设a,b,c为正整数，a=2,b=3,c=4,执行以下程序后a的值为：28  a*=16+(b++)-(++c)    等价于：a=a*(16+3-5)

  

  

13.int j=2,    i    ;  i=(j++,++j,j+2,j-3);    i=1       //注意这里的j+2没有赋值，所以j还是4

  

14.int a=0,b=0,c=0;     c=    (a+=a-=5)    ,    (a=b,b+3);    printf("%d,%d,%d",a,b,c);   //答案是： 0 0 -10

  

15.int a=1,b=2,c=3,d=4;

    printf("%d\\n",a<b?a:c<d?a:d);//答案是：1    等价于：a>b?a:(c<d?c:d)  这种运算要从右边第一个冒号开始计算

  

  

![](C语言例题：_files/Image [2].png)

顺序结构：

  

选择结构：

  

循环结构：

  

数组：

int a\[\]={1,2,3,4,5}; 数组名a就是数组第一个元素的地址值即：int \*p; p=a 等价于 p=&a\[0\] \*(p+i)=a\[i\]

二维数组的定义与初始化：

  

30. 设有数组定义: char array \[ \]="China"; 则数组 array所占的空间为 (C) 

      A) 4 个字节     B) 5个字节     C) 6个字节     D) 7个字节 

  

8. 设变量定义为“int s\[ \]="hello\\nworld\\n";”，则数组s中有\_\_B\_\_\_\_个元素

     A、12     B、13     C、14     D、15 

43、设int型变量占用4个字节，如有定义int x\[10\]={0,2,4};，则数组x在内存中所占的字节数是 D_

    A.2     B.12    C.20    D.40

51、不能将字符串: Hello! 赋给数组b的语句是    (B)

    A. char b\[10\]={'H', 'e','l','l','o', '!','\\O'} ;    B. char b110\] ;b="Hello!";

    C. char b\[10\] ; strcpy(b, "Hello!") ;            D. char b\[10\]="Hello!";

  

指针：

**int * p;****    int i=3;****    p=&i;    //p是变量的名字，int*表示变量p存放的是int类型变量的地址，p保存了i的地址，因此p指向i，*p完全等同于i**

**指针只能进行相减运算**

  

9. int a\[10\]={1,2,3,4,5,6,7,8,9,10},*p=a;    printf("%d\\n",*p+9);//10:1+9=10    *p=1加上9等于⑩

 int a\[10\]={1,2,3,4,5,6,7,8,9,10},*p=a;     printf("%d\\n",*(p+2));//3*p首元素地址，加二移动到第三个地址上

9.  下列程序段的输出是_ ne,s

char \*a\[2\]={"one"; "two"}, \*\*p=a;    printf("%s,", *(p++)+1);    printf("%c\\n"; **p-1);

  

10    char str\[\]="AEIOU", *y=str;      printf("%c\\n",*y+4);    //答案是E

  

函数：

1.scanf函数，scanf("m%d",&i); 这里用户必须输入m123才可以将123付给i，它是为了限定输入的，当输入123时就是非法输入无法得到正确的值

scanf("非输入控制符(,字母等)  输入控制符(%d等)"，输入参数)；在命令行中非输入控制符要原样输出eg：scanf中有逗号就要在命令行中输入逗号

**scanf函数无精度，即没有sacnf("%6.2f",&x);这种方式**

  

2.printf函数：在printf函数中使用格式符%5s，其中数字5表示的是输出字符串占用5列，**如果字符串大于5:按原字符串长从左向右全部输出,如果字符串长小于5：右对齐输出该字符，左侧补空格**

  

  

3.已有如下定义和输入语句, 若要求a1, a2, c1,c2值分别为10, 20,A和B,当从第一列开始输入数据时，正确的数据输入方式是    A

     int  a1, a2;  char  c1, c2;    scanf ("%d%c%d%c" , &al, &c1, &a2, &c2) ;

  

      A)10A 20B  (空格有没有都行，10和A之间不能有空格，否则c1为空格 再输入字符时不能用空格，空格也算一个字符)

      B)10 A 20 B    C) 10A20<CR>      D) 10A20 B<cR>。  

  

4.   void fun(int \*x,int \*y){printf("%d,%d",\*x,\*y)}    int main(){int x=1; int y=2;  fun(&y,&x); printf("%d,%d",x,y);}

        最后的结果是：2     1     4     3

  

  

预编译：

1 下列程序的输出结果是 100    

    #define T 10 

    #define MD 3*T 

    printf(“%d”,30/MD); 

  

 2.宏替换：    #define MA(x) x*(x-1)    int a=1,b=2;    printf("%d\\n",MA(1+a+b));

  ma(1+a + b) = 1+ a + b * (1+a +b -1)

                  = 1+1+2 * (1+1+2-1);

                 = 8    宏就是简单替换，用 1+a + b 去替换x

3.以下程序运行处的结果是：4\*6+8\*6+8+1=81

 #define S(x)  4\*x\*x+1    main(){int i=6,     j=8;    printf(%dn,S(i+j)) ;}

**4.#define MAX(x,y)    (x)>(y)?(x):(y)    **** int t,a=5,b=2,c=3,d=3;    ****t=MAX(a+b,c+d)*10;    **** printf("%d\\n",t);   **

** //答案是7    t=(5+2)>(3+3)?(5+2):(3+3)*10**

  
  

  

结构体和共用体：

  

注意事项：

1.%必须两边都是整数，在做模运算（%）时，符号位取左边的数字的符号eg：5%-3=2    -5%-3=-2

2.scanf函数无精度：scanf（“%6.2f”，&c）这是错误的

3.printf函数中用到格式符%5s，其中数字5表示输出的字符串占五列，如果字符串大于5，则输出按：原字符串从左往右全部输出

    如果字符串小于5，则输出方式按：右对齐输出该字符，左边补空格

  

4.C语言中有四种储存类别分别是：自动的（auto），静态的（static），寄存器的（register），外部的（extern），如果定义局部变量省略了储存类别，则默认是：自动的（auto）

  

5.指针相关的：*（p+1）是指指针所指向的地址前进一位，*p+1是指指针所指向的地址值加一；

    eg：char s【】=“acsf”；\*p=s    \*（p+1）=99（c）   *p+1=98（b）

  

6.    char str\[\]={'g','o','o','d'};错误的字符串赋值形式

  

7.对于基类型相同的两个指针变量之间不能进行的运算是：+

  

C语言指针练习题：

  

 求数组中的第二大的数字

    int a\[\]= {23,455,6757,34,676,909,567,123,111,34};

    int first;

    int second;

    if(*(a+0)>*(a+1))

    {

        first=*(a+0);

        second=*(a+1);

    }

    else

    {

        first=*(a+1);

        second=*(a+0);

    }

    int n=sizeof(a)/sizeof(*a);//元素个数

    int i;

    for(i=2; i<n; i++)

    {

        if(*(a+i)>first)

        {

            second=first;

            first=*(a+i);

        }

        else if(*(a+i)>second && *(a+i)<first)  //*(a+i)有可能等于first

        {

            second=*(a+i);

        }

    }

    printf("second=%d",second);

  

  

  

![](C语言例题：_files/Image [3].png)

![](C语言例题：_files/Image [4].png)

  

![](C语言例题：_files/Image [5].png)

  

![](C语言例题：_files/Image [6].png)

  

  

  

  

  

![](C语言例题：_files/Image [7].png)

  

![](C语言例题：_files/Image [8].png)

  

![](C语言例题：_files/Image [9].png)

  

![](C语言例题：_files/Image [10].png)

  

  

![](C语言例题：_files/Image [11].png)

  

![](C语言例题：_files/Image [12].png)

  

  

  

![](C语言例题：_files/Image [13].png)

  

  

  

有问题的题目：

![](C语言例题：_files/Image [14].png)

    ![](C语言例题：_files/Image [15].png)

        \\141是一个转义字符，\\\141就是114

![](C语言例题：_files/Image [16].png)

![](C语言例题：_files/Image [17].png)

![](C语言例题：_files/Image [18].png)

  

![](C语言例题：_files/Image [19].png)

![](C语言例题：_files/Image [20].png)

![](C语言例题：_files/Image [21].png)
